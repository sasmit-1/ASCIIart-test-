<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pixel to Text | ASCII Art Generator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@300;400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Fira Code', monospace;
            background-color: #0f172a;
            color: #e2e8f0;
        }
        
        /* Custom Scrollbar */
        ::-webkit-scrollbar {
            width: 10px;
            height: 10px;
        }
        ::-webkit-scrollbar-track {
            background: #1e293b; 
        }
        ::-webkit-scrollbar-thumb {
            background: #475569; 
            border-radius: 5px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #64748b; 
        }

        .ascii-output {
            font-family: 'Fira Code', monospace;
            line-height: 0.6; /* Crucial for ASCII aspect ratio */
            white-space: pre;
            overflow-x: auto;
            width: 100%;
        }

        /* Upload Zone Animation */
        .drag-active {
            border-color: #38bdf8 !important;
            background-color: rgba(56, 189, 248, 0.1) !important;
        }

        input[type=range] {
            -webkit-appearance: none; 
            background: transparent; 
        }
        
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 16px;
            width: 16px;
            border-radius: 50%;
            background: #38bdf8;
            cursor: pointer;
            margin-top: -6px; 
        }

        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: #334155;
            border-radius: 2px;
        }
    </style>
</head>
<body class="min-h-screen flex flex-col items-center p-4 sm:p-8">

    <!-- Header -->
    <header class="w-full max-w-6xl flex flex-col md:flex-row justify-between items-center mb-8 gap-4">
        <div>
            <h1 class="text-3xl md:text-4xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-sky-400 to-emerald-400">
                IMG &rarr; ASCII
            </h1>
            <p class="text-slate-400 text-sm mt-1">Turn pixels into poetry.</p>
        </div>
        <div class="flex gap-3">
            <button onclick="loadSample()" class="text-xs text-sky-400 hover:text-sky-300 underline">Load Sample</button>
        </div>
    </header>

    <main class="w-full max-w-6xl grid grid-cols-1 lg:grid-cols-4 gap-8">
        
        <!-- Controls Sidebar -->
        <aside class="lg:col-span-1 flex flex-col gap-6 order-2 lg:order-1">
            
            <!-- Upload Box -->
            <div id="drop-zone" class="border-2 border-dashed border-slate-600 rounded-xl p-6 flex flex-col items-center justify-center text-center transition-colors cursor-pointer hover:border-slate-400 bg-slate-800/50 h-40">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-10 w-10 text-slate-400 mb-2" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z" />
                </svg>
                <p class="text-sm text-slate-300 font-medium">Click or Drop Image</p>
                <p class="text-xs text-slate-500 mt-1">PNG, JPG, WEBP</p>
                <input type="file" id="file-input" class="hidden" accept="image/*">
            </div>

            <!-- Sliders -->
            <div class="bg-slate-800/50 p-5 rounded-xl border border-slate-700 space-y-5">
                
                <!-- Resolution -->
                <div>
                    <div class="flex justify-between text-xs text-slate-400 mb-2">
                        <label>Resolution (Width)</label>
                        <span id="width-val">100 chars</span>
                    </div>
                    <input type="range" id="width-range" min="20" max="300" value="100" class="w-full">
                </div>

                <!-- Contrast -->
                <div>
                    <div class="flex justify-between text-xs text-slate-400 mb-2">
                        <label>Contrast</label>
                        <span id="contrast-val">1.0</span>
                    </div>
                    <input type="range" id="contrast-range" min="0.5" max="3" step="0.1" value="1" class="w-full">
                </div>

                <!-- Character Set -->
                <div>
                    <label class="text-xs text-slate-400 mb-2 block">Character Set</label>
                    <select id="charset-select" class="w-full bg-slate-900 border border-slate-600 text-slate-200 text-xs rounded p-2 focus:outline-none focus:border-sky-500">
                        <option value="standard">Standard (@%#*+=-:. )</option>
                        <option value="complex">Complex ($@B%8&WM#*oahkbdpqwmZO0QLCJUYXzcvunxrjft/\|()1{}[]?-_+~<>i!lI;:,"^`'. )</option>
                        <option value="simple">Simple (#+-. )</option>
                        <option value="blocks">Blocks (█▓▒░ )</option>
                        <option value="binary">Binary (01 )</option>
                    </select>
                </div>

                <!-- Toggles -->
                <div class="flex items-center justify-between">
                    <label class="text-xs text-slate-400">Invert Colors</label>
                    <button id="invert-btn" class="w-10 h-5 rounded-full bg-slate-600 relative transition-colors duration-200">
                        <div class="w-3 h-3 bg-white rounded-full absolute top-1 left-1 transition-transform duration-200 transform"></div>
                    </button>
                </div>

            </div>

            <!-- Output Controls -->
            <div class="grid grid-cols-2 gap-3">
                <button id="copy-btn" class="col-span-2 flex items-center justify-center gap-2 bg-sky-600 hover:bg-sky-500 text-white py-2 rounded-lg text-sm font-semibold transition-all active:scale-95">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 5H6a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2v-1M8 5a2 2 0 012-2h2a2 2 0 012 2m-6 0h6" />
                    </svg>
                    Copy Text
                </button>
                <button id="zoom-out" class="bg-slate-700 hover:bg-slate-600 text-white py-2 rounded-lg text-sm transition-colors">
                    A-
                </button>
                <button id="zoom-in" class="bg-slate-700 hover:bg-slate-600 text-white py-2 rounded-lg text-sm transition-colors">
                    A+
                </button>
            </div>
            
            <!-- Notification Toast (Hidden by default) -->
            <div id="toast" class="hidden fixed bottom-5 left-1/2 transform -translate-x-1/2 bg-emerald-500 text-white px-4 py-2 rounded-lg shadow-lg text-sm font-bold z-50">
                Copied to clipboard!
            </div>

        </aside>

        <!-- Output Area -->
        <section class="lg:col-span-3 bg-black rounded-xl border border-slate-800 relative min-h-[500px] flex flex-col order-1 lg:order-2 shadow-2xl overflow-hidden">
            
            <!-- Canvas (Hidden, used for processing) -->
            <canvas id="canvas" class="hidden"></canvas>

            <!-- Text Output -->
            <div class="flex-1 p-4 overflow-auto flex items-start justify-center bg-black" id="output-container">
                <pre id="ascii-art" class="ascii-output text-[8px] text-white"></pre>
            </div>

            <!-- Loading Overlay -->
            <div id="loading" class="hidden absolute inset-0 bg-black/80 flex flex-col items-center justify-center z-10">
                <div class="animate-spin rounded-full h-12 w-12 border-t-2 border-b-2 border-sky-500"></div>
                <span class="text-sky-500 mt-4 font-mono text-sm">Processing Matrix...</span>
            </div>

            <!-- Empty State -->
            <div id="empty-state" class="absolute inset-0 flex flex-col items-center justify-center text-slate-600 pointer-events-none">
                <span class="text-6xl mb-4 opacity-20">☺</span>
                <p class="text-sm uppercase tracking-widest opacity-40">No Image Loaded</p>
            </div>

        </section>

    </main>

    <footer class="w-full max-w-6xl mt-12 text-center text-slate-600 text-xs pb-8">
        <p>Generated ASCII art can be copied into code comments, text files, or social media.</p>
    </footer>

    <script>
        // --- Configuration & State ---
        const CHAR_SETS = {
            standard: "Ñ@#W$9876543210?!abc;:+=-,._ ",
            complex: "$@B%8&WM#*oahkbdpqwmZO0QLCJUYXzcvunxrjft/\|()1{}[]?-_+~<>i!lI;:,\"^`'. ",
            simple: "#+-. ",
            blocks: "█▓▒░ ",
            binary: "10 "
        };

        let state = {
            image: null,
            width: 100,
            contrast: 1.0,
            inverted: false,
            charSet: "standard",
            fontSize: 8
        };

        // --- DOM Elements ---
        const fileInput = document.getElementById('file-input');
        const dropZone = document.getElementById('drop-zone');
        const asciiOutput = document.getElementById('ascii-art');
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const loadingEl = document.getElementById('loading');
        const emptyStateEl = document.getElementById('empty-state');
        
        // Controls
        const widthRange = document.getElementById('width-range');
        const contrastRange = document.getElementById('contrast-range');
        const charsetSelect = document.getElementById('charset-select');
        const invertBtn = document.getElementById('invert-btn');
        const copyBtn = document.getElementById('copy-btn');
        const zoomInBtn = document.getElementById('zoom-in');
        const zoomOutBtn = document.getElementById('zoom-out');
        
        // Display Values
        const widthVal = document.getElementById('width-val');
        const contrastVal = document.getElementById('contrast-val');

        // --- Event Listeners ---

        // Upload Handling
        dropZone.addEventListener('click', () => fileInput.click());
        fileInput.addEventListener('change', handleFileSelect);

        // Drag & Drop
        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropZone.classList.add('drag-active');
        });
        dropZone.addEventListener('dragleave', () => dropZone.classList.remove('drag-active'));
        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            dropZone.classList.remove('drag-active');
            if (e.dataTransfer.files.length) {
                handleFile(e.dataTransfer.files[0]);
            }
        });

        // Sliders & Inputs
        widthRange.addEventListener('input', (e) => {
            state.width = parseInt(e.target.value);
            widthVal.textContent = `${state.width} chars`;
            requestRender();
        });

        contrastRange.addEventListener('input', (e) => {
            state.contrast = parseFloat(e.target.value);
            contrastVal.textContent = state.contrast.toFixed(1);
            requestRender();
        });

        charsetSelect.addEventListener('change', (e) => {
            state.charSet = e.target.value;
            requestRender();
        });

        invertBtn.addEventListener('click', () => {
            state.inverted = !state.inverted;
            const knob = invertBtn.querySelector('div');
            if (state.inverted) {
                invertBtn.classList.replace('bg-slate-600', 'bg-sky-500');
                knob.classList.add('translate-x-5');
            } else {
                invertBtn.classList.replace('bg-sky-500', 'bg-slate-600');
                knob.classList.remove('translate-x-5');
            }
            requestRender();
        });

        // Zoom
        zoomInBtn.addEventListener('click', () => updateFontSize(1));
        zoomOutBtn.addEventListener('click', () => updateFontSize(-1));

        // Copy
        copyBtn.addEventListener('click', () => {
            const text = asciiOutput.innerText;
            if(!text) return;
            
            navigator.clipboard.writeText(text).then(() => {
                const toast = document.getElementById('toast');
                toast.classList.remove('hidden');
                setTimeout(() => toast.classList.add('hidden'), 2000);
            }).catch(err => {
                // Fallback for older browsers/iframe restrictions
                const textArea = document.createElement("textarea");
                textArea.value = text;
                document.body.appendChild(textArea);
                textArea.select();
                document.execCommand('copy');
                document.body.removeChild(textArea);
                
                const toast = document.getElementById('toast');
                toast.classList.remove('hidden');
                setTimeout(() => toast.classList.add('hidden'), 2000);
            });
        });

        // --- Logic ---

        function handleFileSelect(e) {
            if (e.target.files.length) {
                handleFile(e.target.files[0]);
            }
        }

        function handleFile(file) {
            if (!file.type.match('image.*')) {
                alert("Please select an image file.");
                return;
            }

            const reader = new FileReader();
            loadingEl.classList.remove('hidden');
            
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    state.image = img;
                    emptyStateEl.classList.add('hidden');
                    requestRender();
                    loadingEl.classList.add('hidden');
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        // Sample image for quick testing
        window.loadSample = function() {
             const img = new Image();
             img.crossOrigin = "Anonymous";
             loadingEl.classList.remove('hidden');
             img.onload = () => {
                 state.image = img;
                 emptyStateEl.classList.add('hidden');
                 requestRender();
                 loadingEl.classList.add('hidden');
             };
             // Using a placeholder image
             img.src = "https://images.unsplash.com/photo-1546182990-dced7187a68d?w=600&q=80";
        }

        let renderTimeout;
        function requestRender() {
            if (!state.image) return;
            // Debounce slightly for performance on slider drag
            clearTimeout(renderTimeout);
            renderTimeout = setTimeout(renderAscii, 10);
        }

        function renderAscii() {
            const img = state.image;
            
            // Calculate Aspect Ratio
            // Fonts are usually about twice as tall as they are wide.
            // To keep the image from looking stretched, we must squash the height.
            const aspectRatio = img.height / img.width;
            const fontAspectRatio = 0.55; // Adjust based on font metrics
            
            const finalWidth = state.width;
            const finalHeight = Math.floor(finalWidth * aspectRatio * fontAspectRatio);

            // Resize image via Canvas
            canvas.width = finalWidth;
            canvas.height = finalHeight;
            ctx.drawImage(img, 0, 0, finalWidth, finalHeight);

            // Get Pixel Data
            const imageData = ctx.getImageData(0, 0, finalWidth, finalHeight);
            const data = imageData.data;

            let asciiStr = "";
            const chars = CHAR_SETS[state.charSet];
            
            // Prepare Look Up Table for contrast
            const contrastFactor = (259 * (state.contrast * 255 + 255)) / (255 * (259 - state.contrast * 255));

            for (let y = 0; y < finalHeight; y++) {
                for (let x = 0; x < finalWidth; x++) {
                    const offset = (y * finalWidth + x) * 4;
                    let r = data[offset];
                    let g = data[offset + 1];
                    let b = data[offset + 2];
                    // Alpha = data[offset + 3] - ignored for now, assumed opaque

                    // Apply Contrast
                    r = truncate(contrastFactor * (r - 128) + 128);
                    g = truncate(contrastFactor * (g - 128) + 128);
                    b = truncate(contrastFactor * (b - 128) + 128);

                    // Calculate Brightness (Luminance)
                    const brightness = (0.299 * r + 0.587 * g + 0.114 * b);
                    
                    // Map brightness to character index
                    let charIndex = Math.floor((brightness / 255) * (chars.length - 1));
                    
                    // Handle Inversion (Swap dark/light mapping)
                    if (!state.inverted) {
                        charIndex = (chars.length - 1) - charIndex;
                    }

                    // Safety clamp
                    charIndex = Math.max(0, Math.min(charIndex, chars.length - 1));
                    
                    asciiStr += chars[charIndex];
                }
                asciiStr += "\n";
            }

            asciiOutput.innerText = asciiStr;
        }

        function truncate(value) {
            return Math.max(0, Math.min(255, value));
        }

        function updateFontSize(change) {
            state.fontSize += change;
            if (state.fontSize < 4) state.fontSize = 4;
            if (state.fontSize > 24) state.fontSize = 24;
            asciiOutput.style.fontSize = `${state.fontSize}px`;
        }

    </script>
</body>
</html>